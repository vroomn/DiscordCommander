package main

import (
	"DiscordCommander/requests"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"
)

type GlobalCommands []struct {
	ID                       string      `json:"id"`
	ApplicationID            string      `json:"application_id"`
	Version                  string      `json:"version"`
	DefaultMemberPermissions interface{} `json:"default_member_permissions"`
	Type                     int         `json:"type"`
	Name                     string      `json:"name"`
	Description              string      `json:"description"`
	DmPermission             bool        `json:"dm_permission"`
	Contexts                 []int       `json:"contexts"`
	IntegrationTypes         []int       `json:"integration_types"`
	Nsfw                     bool        `json:"nsfw"`
	Handler                  int         `json:"handler,omitempty"`
}

func getGlobalCommands() GlobalCommands {
	response := requests.GenericRequest(
		http.MethodGet,
		requests.APPLICATION_ENDPOINT+requests.ApplicationID+"/commands",
		nil,
	)

	if response.StatusCode != 200 {
		log.Fatalln("Global list request failed!")
	}

	body, err := io.ReadAll(response.Body)
	if err != nil {
		log.Fatalln("Failed to read response body!")
	}
	response.Body.Close()

	var commands GlobalCommands
	json.Unmarshal(body, &commands)

	return commands
}

type Servers []struct {
	ID             string        `json:"id"`
	Name           string        `json:"name"`
	Icon           interface{}   `json:"icon"`
	Banner         interface{}   `json:"banner"`
	Owner          bool          `json:"owner"`
	Permissions    int           `json:"permissions"`
	PermissionsNew string        `json:"permissions_new"`
	Features       []interface{} `json:"features"`
}

func getServers() Servers {
	response := requests.GenericRequest(
		http.MethodGet,
		"https://discord.com/api/users/@me/guilds",
		nil,
	)
	if response.StatusCode != 200 {
		log.Fatalln("Failed to request servers bot is in!")
	}

	body, err := io.ReadAll(response.Body)
	if err != nil {
		log.Fatalln("Failed to read response body!")
	}
	response.Body.Close()

	var servers Servers
	json.Unmarshal(body, &servers)

	return servers
}

type ServerCommands []struct {
	ID                       string      `json:"id"`
	ApplicationID            string      `json:"application_id"`
	Version                  string      `json:"version"`
	DefaultMemberPermissions interface{} `json:"default_member_permissions"`
	Type                     int         `json:"type"`
	Name                     string      `json:"name"`
	Description              string      `json:"description"`
	GuildID                  string      `json:"guild_id"`
	Nsfw                     bool        `json:"nsfw"`
}

func getServerCommands(guildID string) ServerCommands {
	response := requests.GenericRequest(
		http.MethodGet,
		requests.APPLICATION_ENDPOINT+requests.ApplicationID+"/guilds/"+guildID+"/commands",
		nil,
	)

	if response.StatusCode != 200 {
		log.Fatalln("Global list request failed!")
	}

	body, err := io.ReadAll(response.Body)
	if err != nil {
		log.Fatalln("Failed to read response body!")
	}
	response.Body.Close()

	var commands ServerCommands
	json.Unmarshal(body, &commands)

	return commands
}

func (c CLICommands) ListCommandsHandler() {
	commandTypes := map[int]string{
		1: "Slash command (CHAT_INPUT)",
		2: "UI command when right clicking on user command (USER)",
		3: "UI Command when right clicking on message (MESSAGE)",
		4: "UI Activity Activation, pregenerated by Discord (PRIMARY_ENTRY_POINT)",
	}

	//TODO: Combine different versions of write commands & getter functions

	writeGlobals := func(extendedTab string) {
		commands := getGlobalCommands()

		for i := 0; i < len(commands); i++ {
			fmt.Println(extendedTab + "Command " + strconv.Itoa(i+1) + ": \n" +
				extendedTab + "	-Name: \"" + commands[i].Name + "\"\n" +
				extendedTab + "	-Description: " + commands[i].Description + "\n" +
				extendedTab + "	-Type: " + commandTypes[commands[i].Type])
		}
	}

	writeClanCmds := func(guildID string, extendedTab string) {
		commands := getServerCommands(guildID)

		for i := 0; i < len(commands); i++ {
			fmt.Println(extendedTab + "Command " + strconv.Itoa(i+1) + ": \n" +
				extendedTab + "	-Name: \"" + commands[i].Name + "\"\n" +
				extendedTab + "	-Description: " + commands[i].Description + "\n" +
				extendedTab + "	-Type: " + commandTypes[commands[i].Type])
		}
	}

	switch c.args[c.iterationIdx+1] {
	case "all":
		fmt.Println("Global Commands:")
		writeGlobals("	")

		fmt.Println("\nGuild Commands:")
		servers := getServers()
		for _, server := range servers {
			fmt.Println("	> Clan \"" + server.Name + "\":")
			writeClanCmds(server.ID, "		")
		}

	case "global":
		writeGlobals("")

	case "clan":
		if c.len < c.iterationIdx+3 {
			log.Fatalln("Insufficinet data to run list command!")
		}

		// Check that server is real & grab ID if present
		var serverID string
		serverPresent := false
		servers := getServers()
		for _, server := range servers {
			if server.Name == c.args[c.iterationIdx+2] {
				serverPresent = true
				serverID = server.ID
			}
		}

		if !serverPresent {
			log.Fatalln("Server not found!")
		} else {
			fmt.Println("Found server, id:", serverID)
		}

		writeClanCmds(serverID, "")
	default:
		log.Fatalln("Invalid organization tag")
	}
}
